/* LOGINCommand.cc */

#include	<string>
#include	<iomanip.h>

#include	"md5hash.h"
#include	"StringTokenizer.h"
#include	"ELog.h"
#include	"cservice.h"
#include	"responses.h"
#include	"networkData.h"
#include	"cservice_config.h"
#include	"Network.h"
#include	"events.h"
const char LOGINCommand_cc_rcsId[] = "$Id: LOGINCommand.cc,v 1.11 2002-05-25 17:00:26 jeekay Exp $" ;

namespace gnuworld
{
struct autoOpData {
	string channel_name;
	unsigned int flags;
	unsigned int suspend_expires;
} aOp;

using namespace gnuworld;

bool LOGINCommand::Exec( iClient* theClient, const string& Message )
{
bot->incStat("COMMANDS.LOGIN");

StringTokenizer st( Message ) ;
if( st.size() < 3 )
	{
	Usage(theClient);
	return true;
	}


/*
 * Are we allowing logins yet?
 */
unsigned int loginTime = bot->getUplink()->getStartTime() + bot->loginDelay;
if(loginTime >= (unsigned int)bot->currentTime())
{
	bot->Notice(theClient, "AUTHENTICATION FAILED as %s. (Unable to login during reconnection, please try again in %i seconds)",
		st[1].c_str(), (loginTime - bot->currentTime()));
	return false;
}

/*
 * Allow the login ONLY after burst
 */
/*
if (!bot->getUplink()->IsEndOfBurst()) {
	bot->Notice(theClient, "LOGIN Temporarily disabled while synchronising with network, please try again in a few minutes."); 
	return false;
}
*/
/*
 * Check theClient isn't already logged in, if so, tell
 * them they shouldn't be.
 */

sqlUser* tmpUser = bot->isAuthed(theClient, false);
if (tmpUser)
	{
	bot->Notice(theClient,
		bot->getResponse(tmpUser, language::already_authed).c_str(),
		tmpUser->getUserName().c_str());
	return false;
	}

/*
 * Find the user record, confirm authorisation and attach the record
 * to this client.
 */

if(st[1][0] == '#')
{
	bot->Notice(theClient, "AUTHENTICATION FAILED as %s.", st[1].c_str());
	return false;
}

// TODO: Force a refresh of the user's info from the db
sqlUser* theUser = bot->getUserRecord(st[1]);
if( !theUser )
	{
	bot->Notice(theClient,
		bot->getResponse(tmpUser,
			language::not_registered,
			string("AUTHENTICATION FAILED as %s.")).c_str(),
		st[1].c_str());
	return false;
	}

/*
 *  Compare password with MD5 hash stored in user record.
 */

// MD5 hash algorithm object.
md5	hash;

// MD5Digest algorithm object.
md5Digest digest;

string salt = theUser->getPassword().substr(0, 8);
string md5Part = theUser->getPassword().substr(8);
string guess = salt + st.assemble(2);

// Build a MD5 hash based on our salt + the guessed password.
hash.update( (const unsigned char *)guess.c_str(), guess.size() );
hash.report( digest );

// Convert the digest into an array of int's to output as hex for
// comparison with the passwords generated by PHP.
int data[ MD5_DIGEST_LENGTH ] = { 0 } ;

for( size_t ii = 0; ii < MD5_DIGEST_LENGTH; ii++ )
	{
	data[ii] = digest[ii];
	}

strstream output;
output << hex;
output.fill('0');

for( size_t ii = 0; ii < MD5_DIGEST_LENGTH; ii++ )
	{
	output << setw(2) << data[ii];
	}
output << ends;

if(md5Part != output.str() ) // If the MD5 hash's don't match..
	{
	bot->Notice(theClient,
		bot->getResponse(theUser,
			language::auth_failed,
			string("AUTHENTICATION FAILED as %s.")).c_str(),
		theUser->getUserName().c_str());

	delete[] output.str() ;
	return false;
	}

delete[] output.str() ;

/*
 *  Check this user isn't already spoken for..
 *  If someone HAS authenticated as this user, then deauth that other
 *  person.
 */

iClient* authTestUser = theUser->isAuthed();
if (authTestUser)
	{
	bot->Notice(authTestUser,
		bot->getResponse(tmpUser,
			language::no_longer_auth,
			string("NOTICE: %s has now authenticated as %s, you are no longer authenticated.")).c_str(),
			theClient->getNickUserHost().c_str(),
			theUser->getUserName().c_str());

	networkData* tmpData =
		static_cast< networkData* >( authTestUser->getCustomData(bot) ) ;
	if( NULL == tmpData )
		{
		bot->Notice( authTestUser,
			"Internal error." ) ;
		elog	<< "LOGINCommand> tmpData is NULL for: "
			<< *authTestUser
			<< endl ;
		return false ;
		}

	// Remove the pointer from the iClient to the sqlUser.
	tmpData->currentUser = NULL;
	server->PostEvent(gnuworld::EVT_FORCEDEAUTH, 
										static_cast< void* >( authTestUser));
	}

string uname = theUser->getUserName();
server->PostEvent(gnuworld::EVT_LOGGEDIN
	,static_cast<void*>(theClient)
	    ,static_cast<void*>(&uname));
theUser->setLastSeen(bot->currentTime(), theClient->getNickUserHost());
theUser->setFlag(sqlUser::F_LOGGEDIN);
theUser->networkClient = theClient; // Who is authed as this user.

networkData* newData =
	static_cast< networkData* >( theClient->getCustomData(bot) ) ;
if( NULL == newData )
	{
	bot->Notice( authTestUser,
		"Internal error." ) ;
	elog	<< "LOGINCommand> newData is NULL for: "
		<< *authTestUser
		<< endl ;
	return false ;
	}

// Pointer back to the sqlUser from this iClient.
newData->currentUser = theUser;

bot->Notice(theClient,
	bot->getResponse(theUser, language::auth_success).c_str(),
	theUser->getUserName().c_str());

/*if(strcasecmp(theClient->getNickName(),st[1]))
	{
	bot->Notice(theClient,"You didn't login as your nickname. if that is because your nickname is taken, you can use the RECOVER command to get it back");
	}
*/
/*
 * If the user account has been suspended, make sure they don't get
 * auto-opped.
 */

if (theUser->getFlag(sqlUser::F_GLOBAL_SUSPEND))
	{
	bot->Notice(theClient,
		"..however your account has been suspended by a CService administrator."
		" You will be unable to use any channel access you may have.");
	return true;
	}

/*
 * The fun part! For all channels this user has access on, and has
 * AUTOP set, and isn't already op'd on - do the deed.
 */

strstream theQuery;
theQuery	<< "SELECT channels.name,levels.flags,levels.suspend_expires FROM "
			<< "levels,channels WHERE channels.id=levels.channel_id AND levels.user_id = "
			<< theUser->getID()
			<< ends;

#ifdef LOG_SQL
	elog	<< "LOGIN::sqlQuery> "
		<< theQuery.str()
		<< endl;
#endif

ExecStatusType status = bot->SQLDb->Exec(theQuery.str()) ;
delete[] theQuery.str() ;

if( PGRES_TUPLES_OK != status )
	{
	elog	<< "LOGIN> SQL Error: "
		<< bot->SQLDb->ErrorMessage()
		<< endl ;
	return false ;
	}

typedef vector < autoOpData > autoOpVectorType;
autoOpVectorType autoOpVector;

for(int i = 0; i < bot->SQLDb->Tuples(); i++)
	{
		autoOpData current;

		current.channel_name = bot->SQLDb->GetValue(i, 0);
		current.flags = atoi(bot->SQLDb->GetValue(i, 1));
		current.suspend_expires = atoi(bot->SQLDb->GetValue(i, 2));

		autoOpVector.push_back( autoOpVectorType::value_type(current) );
		
	}

for (autoOpVectorType::const_iterator resultPtr = autoOpVector.begin();
	resultPtr != autoOpVector.end(); ++resultPtr)
	{

	/*
	 *  Would probably be wise to check they're not suspended too :)
	 *  (*smack* Ace)
	 *	GK@PAnet: Lets do this first to save time
	 */

	if(resultPtr->suspend_expires > 0) { continue; }

	/* If the auto(op/voice/invite) flag isn't set in this record */
	if (!(resultPtr->flags & sqlLevel::F_AUTOOP) &&
	#ifdef FEATURE_INVITE
		!(resultPtr->flags & sqlLevel::F_AUTOINVITE) &&
	#endif
		!(resultPtr->flags & sqlLevel::F_AUTOVOICE))
		{
		continue;
		}

	/*
	 * Is this channel registered?
	 */
	
	sqlChannel* theChan = bot->getChannelRecord(resultPtr->channel_name);
	if (!theChan) { continue; }

	/* 
   * Make sure the channel isn't suspended.. 
   */ 
    
	if (theChan->getFlag(sqlChannel::F_SUSPEND)) 
		{ continue; } 

	/*
	 * Check they aren't banned < 75 in the chan.
	 * GK@PAnet: This also stops autoinvite and autovoice.. bug?
	 */

	sqlBan* tmpBan = bot->isBannedOnChan(theChan, theClient);
	if( tmpBan && (tmpBan->getLevel() < 75) )
		{ continue; }

	/*
	 * Does the channel currently exist on the network?
	 */

	Channel* netChan = Network->findChannel(theChan->getName());
	if (!netChan) { continue; }
	
	/*
	 * Don't attempt to do anything if we're not in the channel, or not op'd.
	 */

	ChannelUser* tmpBotUser = netChan->findUser(bot->getInstance());
	if (!tmpBotUser) { continue; }

	if (!theChan->getInChan() || !tmpBotUser->getMode(ChannelUser::MODE_O))
		{ continue; }
	
	/*
	 * Attempt to find the user in the channel
	 */

	ChannelUser* tmpChanUser = netChan->findUser(theClient) ;
	
#ifdef FEATURE_INVITE
	/*
	 * If the user is not in the channel and they have the
	 * AUTOINVITE flag set, invite them!
	 */

	bot->Notice(theClient, "Checking for autoinvite");
	if(!tmpChanUser && (resultPtr->flags & sqlLevel::F_AUTOINVITE))
		{ bot->Invite(theClient, netChan->getName()); }
#endif
	
	/*
	 * If the user is not in the channel, we cant op/voice them
	 */
	
	if(!tmpChanUser) { continue; }

	/*
	 * Check if the channel is NOOP.
	 * N.B: If the channel is strictop, we op them.
	 * They've just logged in! :P
	 */

	if(theChan->getFlag(sqlChannel::F_NOOP))
		{	continue;	}

	/*
 	 *  If its AUTOOP, check for op's and do the deed.
	 *  Otherwise, its just AUTOVOICE :)
	 */

	if (resultPtr->flags & sqlLevel::F_AUTOOP)
		{
		if(!tmpChanUser->getMode(ChannelUser::MODE_O))
			{
			bot->Op(netChan, theClient);
			}
		}
		else if(resultPtr->flags & sqlLevel::F_AUTOVOICE)
		{
		if(!tmpChanUser->getMode(ChannelUser::MODE_V))
			{
			bot->Voice(netChan, theClient);
			}
		}

	}

#ifdef FEATURE_MEMOSERV
	/*
	 *  Now check if we have any notes
	 */
	
	strstream notesQuery;
	notesQuery	<< "SELECT COUNT(id) FROM memo WHERE to_id = "
							<< theUser->getID() << ends;
#ifdef LOG_SQL
	elog	<< "LOGIN::sqlQuery> "
		<< notesQuery.str()
		<< endl;
#endif
	status = bot->SQLDb->Exec(notesQuery.str()) ;
	delete[] notesQuery.str() ;

if( PGRES_TUPLES_OK != status )
	{
	elog	<< "LOGIN> SQL Error: "
		<< bot->SQLDb->ErrorMessage()
		<< endl ;
	return false ;
	}

if (bot->SQLDb->Tuples() > 0 && atoi(bot->SQLDb->GetValue(0, 0)) > 0)
	{
		bot->Notice(theClient, "You have %d note(s). To view them, type \002/msg %s note read\002.",
			atoi(bot->SQLDb->GetValue(0, 0)), bot->getNickName().c_str());
	}
#endif

/*
 *  And last but by no means least, see if we have been nominated as
 *  a supporter for a channel.
 */

strstream supporterQuery;
supporterQuery	<< "SELECT channels.name FROM"
			<< " supporters,channels,pending WHERE"
			<< " supporters.channel_id = channels.id"
			<< " AND pending.channel_id = channels.id"
			<< " AND channels.registered_ts = 0"
			<< " AND supporters.support = '?'"
			<< " AND pending.status = 0"
			<< " AND user_id = "
			<< theUser->getID()
			<< ends;

#ifdef LOG_SQL
	elog	<< "LOGIN::sqlQuery> "
		<< supporterQuery.str()
		<< endl;
#endif

status = bot->SQLDb->Exec(supporterQuery.str()) ;
delete[] supporterQuery.str() ;

if( PGRES_TUPLES_OK != status )
	{
	elog	<< "LOGIN> SQL Error: "
		<< bot->SQLDb->ErrorMessage()
		<< endl ;
	return false ;
	}


for(int i = 0; i < bot->SQLDb->Tuples(); i++)
	{
		string channelName = bot->SQLDb->GetValue(i, 0);
		string botName = bot->getNickName();
		bot->Notice(theClient, "You have been named as a supporter in a new channel application for %s. You may visit the website to register your support or to make an objection. Alternatively, you can type '\002/msg %s support %s YES\002' or '\002/msg %s support %s NO\002' to confirm or deny your support.", channelName.c_str(), botName.c_str(), channelName.c_str(), botName.c_str(), channelName.c_str());
	}

return true;
}

} // namespace gnuworld.

